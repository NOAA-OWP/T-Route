# -*- coding: utf-8 -*-
"""Network Analysis via Parallelization Demo

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fg0W8z_OyI2CtF94Wyk5W-vjbCgBE5fz

#### NHD Network Analysis Demo
The following analysis tool has been applied to the NHD network. We hope to identify the complexity inherent in the network at different levels of resolution. The goal is also to be able to manage the complexity calculation for arbitrary collections of headwater points, such as might be obtained from a list of named streams.<br>
The network complexity is related to the potential for parallelization of a serial analysis of the network.<br>
The network analysis assumes that the downstream neighbor is identified in the table for each stream segment. <br>
"""

import networkbuilder as networkbuilder
import recursive_print
import os
import geopandas as gpd
# -*- coding: utf-8 -*-
"""NHD Network traversal

A demonstration version of this code is stored in this Colaboratory notebook:
https://colab.research.google.com/github/jameshalgren/wrf_hydro_nwm_public/blob/network/trunk/NDHMS/dynamic_channel_routing/notebooks/NHD_Network_Density_Analysis.ipynb#scrollTo=h_BEdl4LID34

"""
def do_network(
        geofile_path = None
        , title_string = None
        , layer_string = None
        , driver_string = None
        , key_col = None
        , downstream_col = None
        , length_col = None
        , terminal_code = None
        , verbose = False
        , debuglevel = 0
        ):

    # NOTE: these methods can lose the "connections" and "rows" arguments when
    # implemented as class methods where those arrays are members of the class.
    if verbose: print(title_string)
    if debuglevel <= -1: print(f'reading -- dataset: {geofile_path}; layer: {layer_string}; fiona driver: {driver_string}')
    geofile = gpd.read_file(geofile_path, driver=driver_string, layer=layer_string)
    if debuglevel <= -1: print(geofile.head())
    geofile_rows = geofile.to_numpy()
    if debuglevel <= -1: geofile.plot()
    # Kick off recursive call for all connections and keys
    (connections) = networkbuilder.get_down_connections(
                    rows = geofile_rows
                    , key_col = key_col
                    , downstream_col = downstream_col
                    , length_col = length_col
                    , verbose = verbose
                    , debuglevel = debuglevel)

    (all_keys, ref_keys, headwater_keys
        , terminal_keys
        , terminal_ref_keys
        , circular_keys) = networkbuilder.determine_keys(
                    connections = connections
                    , key_col = key_col
                    , downstream_col = downstream_col
                    , terminal_code = terminal_code
                    , verbose = verbose
                    , debuglevel = debuglevel)

    (junction_keys) = networkbuilder.get_up_connections(
                    connections = connections
                    , terminal_code = terminal_code
                    , headwater_keys = headwater_keys
                    , terminal_keys = terminal_keys
                    , verbose = verbose
                    , debuglevel = debuglevel)
    return connections, all_keys, ref_keys, headwater_keys \
        , terminal_keys, terminal_ref_keys \
        , circular_keys, junction_keys

def do_print():
    recursive_print.print_basic_network_info(
                    connections = connections_NHD
                    , headwater_keys = headwater_keys_NHD
                    , junction_keys = junction_keys_NHD
                    , terminal_keys = terminal_keys_NHD
                    , terminal_code = terminal_code_NHD
                    , verbose = True
                    )

    if 1 == 0: #THE RECURSIVE PRINT IS NOT A GOOD IDEA WITH LARGE NETWORKS!!!
        recursive_print.print_connections(
                    headwater_keys = headwater_keys_NHD
                    , down_connections = connections_NHD
                    , up_connections = connections_NHD
                    , terminal_code = terminal_code_NHD
                    , terminal_keys = terminal_keys_NHD
                    , terminal_ref_keys = terminal_ref_keys_NHD
                    , debuglevel = -2
                    )

#root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
test_folder = os.path.join(root, r'test')
geo_input_folder = os.path.join(test_folder, r'input', r'geo', r'Channels')

"""##NHD CONUS order 5 and greater"""
CONUS_ge5 = True
"""##NHD Subset (Brazos/Lower Colorado)"""
Brazos_LowerColorado_ge5 = True
CONUS_FULL_RES = False

debuglevel = -1
verbose = True

# The following datasets are extracts from the feature datasets available
# from https://www.nohrsc.noaa.gov/pub/staff/keicher/NWM_live/web/data_tools/
# the CONUS_ge5 and Brazos_LowerColorado_ge5 datasets are included
# in the github test folder

if CONUS_ge5:
    nhd_conus_file_path = os.path.join(geo_input_folder
            , r'NHD_Conus_Channels.shp')
    key_col_NHD = 1
    downstream_col_NHD = 6
    length_col_NHD = 5
    terminal_code_NHD = 0
    title_string = 'CONUS Order 5 and Greater '
    driver_string = 'ESRI Shapefile'
    layer_string = 0

    CONUS_ge5_values = do_network (nhd_conus_file_path
                , title_string = title_string
                , layer_string = layer_string
                , driver_string = driver_string
                , key_col = key_col_NHD
                , downstream_col = downstream_col_NHD
                , length_col = length_col_NHD
                , terminal_code = terminal_code_NHD
                , verbose = verbose
                , debuglevel = debuglevel)


if CONUS_FULL_RES:
    nhd_conus_file_path = os.path.join(geo_input_folder
            , r'channels_nwm_V12_routeLink_all.shp')
    key_col_NHD = 0
    downstream_col_NHD = 5
    length_col_NHD = 4
    terminal_code_NHD = 0
    title_string = 'CONUS Full Resolution NWM v1.2'
    driver_string = 'ESRI Shapefile'
    layer_string = 0

    do_network (nhd_conus_file_path
                , title_string = title_string
                , layer_string = layer_string
                , driver_string = driver_string
                , key_col = key_col_NHD
                , downstream_col = downstream_col_NHD
                , length_col = length_col_NHD
                , terminal_code = terminal_code_NHD
                , verbose = verbose
                , debuglevel = debuglevel)

if Brazos_LowerColorado_ge5:
    nhd_conus_file_path = os.path.join(geo_input_folder
            , r'NHD_BrazosLowerColorado_Channels.shp')
    key_col_NHD = 2
    downstream_col_NHD = 7
    length_col_NHD = 6
    terminal_code_NHD = 0
    title_string = 'Brazos + Lower Colorado\nNHD stream orders 5 and greater\n'
    title_string = 'CONUS Order 5 and Greater '
    driver_string = 'ESRI Shapefile'
    layer_string = 0

    Brazos_LowerColorado_ge5_values = do_network (nhd_conus_file_path
                , title_string = title_string
                , layer_string = layer_string
                , driver_string = driver_string
                , key_col = key_col_NHD
                , downstream_col = downstream_col_NHD
                , length_col = length_col_NHD
                , terminal_code = terminal_code_NHD
                , verbose = verbose
                , debuglevel = debuglevel)

"""######Header cell to permit folding"""

# def main():
if 1 == 1:
    """##TEST"""
    print("")
    print ('Executing Test')
    # Test data
    test_rows = [
        [50,178,51,0],
        [51,178,50,0],
        [60,178,61,0],
        [61,178,62,0],
        [62,178,60,0],
        [70,178,71,0],
        [71,178,72,0],
        [72,178,73,0],
        [73,178,70,0],
        [80,178,81,0],
        [81,178,82,0],
        [82,178,83,0],
        [83,178,84,0],
        [84,178,80,0],
        [0,456,-999,0],
        [1,178,4,0],
        [2,394,0,0],
        [3,301,2,0],
        [4,798,0,0],
        [5,679,4,0],
        [6,523,0,0],
        [7,815,2,0],
        [8,841,-999,0],
        [9,514,8,0],
        [10,458,9,0],
        [11,832,10,0],
        [12,543,11,0],
        [13,240,12,0],
        [14,548,13,0],
        [15,920,14,0],
        [16,920,15,0],
        [17,514,16,0],
        [18,458,17,0],
        [19,832,18,0],
        [20,543,19,0],
        [21,240,16,0],
        [22,548,21,0],
        [23,920,22,0],
        [24,240,23,0],
        [25,548,12,0],
        [26,920,25,0],
        [27,920,26,0],
        [28,920,27,0],
    ]

    test_key_col = 0
    test_downstream_col = 2
    test_length_col = 1
    test_terminal_code = -999
    debuglevel = 0
    verbose = True

    (test_connections) = networkbuilder.get_down_connections(
                rows = test_rows
                , key_col = test_key_col
                , downstream_col = test_downstream_col
                , length_col = test_length_col
                , verbose = True
                , debuglevel = debuglevel
                )

    (test_all_keys, test_ref_keys, test_headwater_keys
     , test_terminal_keys
     , test_terminal_ref_keys
     , test_circular_keys) = networkbuilder.determine_keys(
                connections = test_connections
                , key_col = test_key_col
                , downstream_col = test_downstream_col
                , terminal_code = test_terminal_code
                , verbose = True
                , debuglevel = debuglevel
                )

    test_junction_keys = networkbuilder.get_up_connections(
                connections = test_connections
                , terminal_code = test_terminal_code
                , headwater_keys = test_headwater_keys
                , terminal_keys = test_terminal_keys
                , verbose = True
                , debuglevel = debuglevel
                )

    recursive_print.print_connections(
                headwater_keys = test_headwater_keys
                , down_connections = test_connections
                , up_connections = test_connections
                , terminal_code = test_terminal_code
                , terminal_keys = test_terminal_keys
                , terminal_ref_keys = test_terminal_ref_keys
                , debuglevel = debuglevel
                )

    recursive_print.print_basic_network_info(
                connections = test_connections
                , headwater_keys = test_headwater_keys
                , junction_keys = test_junction_keys
                , terminal_keys = test_terminal_keys
                , terminal_code = test_terminal_code
                , verbose = True
                , debuglevel = debuglevel
                )


# if __name__ == "__main__":
#     main()

"""######Header cell to permit folding"""

#parallel compute
import time
import multiprocessing

terminal_keys = CONUS_ge5_values[4]
circular_keys = CONUS_ge5_values[6]
terminal_keys_super = terminal_keys - circular_keys
con = CONUS_ge5_values[0]
# terminal_code = terminal_code_NHD
terminal_code = terminal_code_NHD
print(terminal_code)
# terminal_keys = test_terminal_keys
# circular_keys = test_circular_keys
# terminal_keys_super = terminal_keys - circular_keys
# con = test_connections
# teminal_code = test_terminal_code
# terminal_keys = Brazos_LowerColorado_ge5_values[4]
# circular_keys = Brazos_LowerColorado_ge5_values[6]
# terminal_keys_super = terminal_keys - circular_keys
# con = Brazos_LowerColorado_ge5_values[0]
# terminal_code = terminal_code_NHD

super_networks = {terminal_key:{}
                        for terminal_key in terminal_keys_super}
debuglevel = 0
verbose = False

def recursive_junction_read (
                             keys
                             , network
                             , terminal_code = 0
                             , verbose = False
                             , debuglevel = 0
                            ):
    global con
    for key in keys:
        ckey = key
        ukeys = con[key]['upstreams']
        while not len(ukeys) >= 2 and not (ukeys == [terminal_code]):
            if debuglevel <= -2: print(f"segs at ckey {ckey}: {network['segment_count']}")
            # the terminal code will indicate a headwater
            if debuglevel <= -3: print(ukeys)
            (ckey,) = ukeys
            ukeys = con[ckey]['upstreams']
        if ukeys == [terminal_code]:
            if debuglevel <= -1: print(f"headwater found at {ckey}")
            network['segment_count'] += 1
            if debuglevel <= -2: print(f"segs at ckey {ckey}: {network['segment_count']}")
        elif len(ukeys) >= 2:
            network['segment_count'] += 1
            if debuglevel <= -1: print(f"junction found at {ckey} with upstreams {ukeys}")
            network['segment_count'] += 1
            if debuglevel <= -2: print(f"segs at ckey {ckey}: {network['segment_count']}")
            network['junction_count'] += 1 #the Terminal Segment
            recursive_junction_read (ukeys, network, verbose = verbose, debuglevel = debuglevel)
            # print(ukeys)
            ukeys = con[ckey]['upstreams']
            ckey = ukeys

def super_network_trace(
                        nid
                        , verbose= False
                        , terminal_code = 0
                        , debuglevel = 0
                        ):

    network = {}
    global con

    if verbose: print(f'\ntraversing upstream on network {nid}:')
    # try:
    if 1 == 1:
        network.update({'junction_count': 0})
        network.update({'segment_count': 0}) #the Terminal Segment
        recursive_junction_read([nid], network, verbose = verbose, terminal_code = terminal_code, debuglevel = debuglevel)
        if verbose: print(f"junctions: {network['junction_count']}")
        if verbose: print(f"segments: {network['segment_count']}")
    # except Exception as exc:
    #     print(exc)
    return network


# start_time = time.time()
# results_serial = {}
# for nid, network in super_networks.items():
#     network.update({nid: super_network_trace(nid, verbose = verbose, debuglevel = debuglevel)})
#     # super_network_trace(nid, con, network, terminal_code, debuglevel = debuglevel
# print("--- %s seconds ---" % (time.time() - start_time))
#
# print(super_networks.items())
# print(len(super_networks.items()))
nids = (nid for nid in super_networks)
# networks = ((nid, network) for nid, network in super_networks.items())
start_time = time.time()
with multiprocessing.Pool() as pool:
    # results = pool.starmap(super_network_trace, [(nid, network) for nid, network in super_networks.items()])
    results = pool.map(super_network_trace, nids)
    # results = pool.starmap(super_network_trace, networks)
    print("--- %s seconds ---" % (time.time() - start_time))

print(results)

#multi from jake
#runs extremely slow
import time
import multiprocessing as mp
# import pdb; pdb.set_trace()

pool = mp.Pool(mp.cpu_count())
'''terminal_keys = Brazos_LowerColorado_ge5_values[4]
circular_keys = Brazos_LowerColorado_ge5_values[6]
terminal_keys_super = terminal_keys - circular_keys
con = Brazos_LowerColorado_ge5_values[0]'''
terminal_keys = CONUS_ge5_values[4]
circular_keys = CONUS_ge5_values[6]
terminal_keys_super = terminal_keys - circular_keys
con = CONUS_ge5_values[0]

super_networks = {terminal_key:{}
                        for terminal_key in terminal_keys_super}
debuglevel = 0

start_time = time.time()


results = [pool.apply(super_network_trace, args=(nid, con, network, terminal_code, 0)) for nid, network in super_networks.items()]

pool.close()

print(results)
#print(con)
#print(super_networks)
print("--- %s seconds ---" % (time.time() - start_time))
